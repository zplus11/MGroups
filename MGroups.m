(* ::Package:: *)

BeginPackage["MGroups`"]

FormGroup::usage="Form a group with the domain and function.
FormGroup[domain,bin_op]"
FindDomain::usage="Find the domain of the group.
FindDomain[G]"
FindIdentity::usage="Find the identity of the group.
FindIdentity[G]"
ElementPower::usage="Find order of an element of the group.
ElementPower[G, element, power]"
OrderGroup::usage="Find order of the group.
OrderGroup[G]"
ElementInverse::usage="Find the inverse of an element of the group.
ElementInverse[G, element]"
OrderElement::usage="Find the order of an element of the group.
OrderElement[G, element]"
CyclicQ::usage="Check whether the group is cyclic or not.
CyclicQ[G]"
AbelianQ::usage="Check whether the group is abelian or not.
AbelianQ[G]"
CayleyTable::usage="Print the Cayley Table of the group.
CayleyTable[G]"
InversesTable::usage="Print the table of inverses (and orders) of the group.
InversesTable[G]"
SubgroupQ::usage="Check whether a subset forms a subgroup of the group or not.
SubgroupQ[G, H]"
GenerateSubgroup::usage="Get the subgroup generated by an element.
GenerateSubgroup[G, x]"
Subgroups::usage="Find all subgroups of the group.
Subgroups[G]"
SubgroupLattice::usage="Show the subgroup lattice of the group.
SubgroupLattice[G]"
SubgroupLattice1::usage="Show the subgroup lattice of the group with given subgroups.
SubgroupLattice1[G]"
Coset::usage="Generate a coset of the group.
Coset[G,H,element,orientation"
NormalSubgroupQ::usage="Check whether a subgroup of the group is normal in it or not.
NormalSubgroupQ[G,H]"
NormalSubgroups::usage="Find all normal subgroups of the group.
NormalSubgroups[G]"
Homomorphism::usage="Define a homomorphism between 2 groups.
Homomorphism[G1, G2, phi]"
KernelMorphism::usage="Find the kernel of a Morphism.
KernalMorphism[phi, G2]"
Isomorphism::usage="Define an isomorphism between 2 groups.
Isomorphism[G1, G2, phi]"
Automorphism::usage="Define an automorphism in the group.
Automorphism[G, phi]"
InnerAutomorphism::usage="Define an inner automorphism in the group by an element.
InnerAutomorphism[G, x]"
VisualiseMorphism::usage="Visualise a morphism between groups.
VisualiseMorphism[M]"
AdditiveGroup::usage="Addivitive group of order \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\).
AdditiveGroup[n]"
MultiplicativeGroup::usage="Multiplicative group of order phi(\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)).
MultiplicativeGroup[n]"
DihedralGroupp::usage="Dihedral group of order \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\).
DihedralGroupp[n]"
Klein4Group::usage="Klein 4-Group
Klein4Group"
QuaternionGroup::usage="Quaternion Group
QuaternionGroup"
ExternalDirectProduct::usage="External Direct Product of \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) groups: \!\(\*SubscriptBox[\(G\), \(1\)]\), \!\(\*SubscriptBox[\(G\), \(2\)]\), ..., \!\(\*SubscriptBox[\(G\), \(3\)]\).
ExternalDirectProduct[G1, G2, ..., Gn]"
 
Begin["`Private`"]

MapToAssociationQ[_->_?AssociationQ]:=True
MapToAssociationQ[___]:=False
GroupQ[Association[___?MapToAssociationQ]]:=True
GroupQ[___]:=False

FormGroup[domain_List,binop_]:=<|Table[x-><|Table[y->binop[{y,x}],{y,domain}]|>,{x,domain}]|>

FindDomain[G_?GroupQ]:=Return[Keys[G]]

FindIdentity[G_?GroupQ]:=Module[
{domain},
Catch[
domain=FindDomain[G];
Do[If[And@@Table[G[x][y]==y==G[y][x],{y,domain}],Throw[x]],{x,domain}];
Throw[Null];
]
]

ElementPower[G_?GroupQ,element_,power_]:=Module[
{domain,result},
Catch[
domain=FindDomain[G];
If[!MemberQ[domain,element],Throw["Invalid Member"]];
result=FindIdentity[G];
Do[result=G[element][result],{i,power}];
Throw[result]
]
]

OrderGroup[G_?GroupQ]:=Return[Length[FindDomain[G]]]
OrderElement[G_?GroupQ,element_]:=Module[
{domain,identity},
Catch[
domain=FindDomain[G];
If[!MemberQ[domain,element],Throw["Invalid Member"]];
identity=FindIdentity[G];
Do[If[ElementPower[G,element,i]==identity,Throw[i]],{i,Divisors[OrderGroup[G]]}];
Throw[Null]
]
]

ElementInverse[G_?GroupQ,element_]:=Module[
{domain,identity},
Catch[
domain=FindDomain[G];
If[!MemberQ[domain,element],Throw["Invalid Member"]];
identity=FindIdentity[G];
Do[If[G[element][x]==identity==G[x][element],Throw[x]],{x,domain}];
Throw[Null];
]
]

CyclicQ[G_?GroupQ]:=Module[
{domain,grouporder},
Catch[
domain=FindDomain[G];
grouporder=OrderGroup[G];
Do[If[OrderElement[G,x]==grouporder,Throw[True]],{x,domain}];
Throw[False];
]
]

AbelianQ[G_?GroupQ]:=Module[
{domain},
Catch[
domain=FindDomain[G];
Do[If[G[x][y]!=G[y][x],Throw[False]],{x,domain},{y,domain}];
Throw[True]
]
]

CayleyTable[G_?GroupQ]:=Module[
{domain},
domain=FindDomain[G];
TableForm[Table[Table[G[x][y],{y,domain}],{x,domain}],TableHeadings->{domain,domain}]
]

InversesTable[G_?GroupQ]:=Module[
{domain},
domain=FindDomain[G];
TableForm[Table[{x,ElementInverse[G,x],OrderElement[G,x]},{x,FindDomain[G]}],TableHeadings->{None,{"x","\!\(\*SuperscriptBox[\(x\), \(-1\)]\)","|x|"}}]
]

SubgroupQ[G_?GroupQ,H_?ListQ]:=Module[
{domain,identity},
Catch[
domain=FindDomain[G];
identity=FindIdentity[G];
If[!MemberQ[H,identity],Throw[False]];
If[!SubsetQ[domain, H],Throw[False]];
Do[If[!MemberQ[H,G[x][y]],Throw[False]],{x,H},{y,H}];
Throw[True]
]
]

GenerateSubgroup[G_?GroupQ, x_]:=Module[
{domain},
Catch[
domain=FindDomain[G];
If[!MemberQ[domain,x],Throw["Invalid member"]];
Throw[Table[ElementPower[G,x,i],{i,OrderElement[G,x]}]]
]
]

getGenerator[G_?GroupQ]:=Module[
{domain,gorder},
Catch[
domain=FindDomain[G];
gorder=OrderGroup[G];
Do[If[OrderElement[G,x]==gorder,Throw[x]],{x,domain}];
Throw[Null]
]
]
Subgroups[G_?GroupQ]:=Module[
{subsets,gen},
gen=getGenerator[G];
If[gen=!=Null,
Return[Table[GenerateSubgroup[G,ElementPower[G,gen,i]],{i,Divisors[OrderGroup[G]]}]],
subsets=Complement[Subsets[FindDomain[G]],{{}}];
Return[Select[subsets,SubgroupQ[G,#]&]]
]
]

coversQ[R_,{x_,y_}]:=Module[
{z,checkSet},
Catch[
If[x==y||!MemberQ[R,{x,y}],Throw[False]];
checkSet=Complement[Union[Flatten[R, 1]],{x,y}];
Do[If[MemberQ[R,{x,z}]&&MemberQ[R,{z,y}],Throw[False]],{z,checkSet}];
Throw[True]
]
]
SubgroupLattice[G_?GroupQ]:=Module[
{subgroups,rel,edges},
subgroups=Table[<|Table[x-><|Table[y->G[x][y],{y,group}]|>,{x,group}]|>,{group,Subgroups[G]}];
rel=Select[Tuples[subgroups,2],SubgroupQ[#[[2]],Keys[#[[1]]]]&];
edges=(#[[2]]->#[[1]])&/@(Select[rel,coversQ[rel,#]&]);
LayeredGraphPlot[edges,PlotStyle->RGBColor["#4A84FF"]]
]
SubgroupLattice1[G_?GroupQ, subs_]:=Module[
{subgroups,rel,edges},
subgroups=Table[<|Table[x-><|Table[y->G[x][y],{y,group}]|>,{x,group}]|>,{group,subs}];
rel=Select[Tuples[subgroups,2],SubgroupQ[#[[2]],Keys[#[[1]]]]&];
edges=(#[[2]]->#[[1]])&/@(Select[rel,coversQ[rel,#]&]);
LayeredGraphPlot[edges,PlotStyle->RGBColor["#4A84FF"]]
]

Coset[G_?GroupQ,H_,element_,orientation_:"l"]:=Module[
{domain},
Catch[
domain=FindDomain[G];
If[!SubgroupQ[G,H],Throw["Invalid Subgroup"]];
If[!MemberQ[domain,element],Throw["Invalid Member"]];
If[!MemberQ[{"l","r"},orientation],Throw["Invalid Orientation"]];
If[orientation=="l",
Throw[Table[G[x][element],{x,H}]],
Throw[Table[G[element][x],{x,H}]]
]
]
]

NormalSubgroupQ[G_?GroupQ,H_]:=Module[
{domain},
Catch[
domain=FindDomain[G];
If[!SubgroupQ[G,H],Throw[False]];
Do[If[!(Sort@Coset[G,H,x,"l"]===Sort@Coset[G,H,x,"r"]),Throw[False]],{x,domain}];
Throw[True];
]
]

NormalSubgroups[G_?GroupQ]:=Module[
{subgroups},
subgroups=Subgroups[G];
Return[Select[subgroups,NormalSubgroupQ[G,#]&]]
]

map[domain_,def_]:=Return[<|Table[x->def[x],{x,domain}]|>];

Homomorphism[G1_?GroupQ,G2_?GroupQ,def_]:=Module[
{domain},
Catch[
domain=FindDomain[G1];
If[Or@@Flatten[Table[def[G1[x][y]]!=G2[def[x]][def[y]],{x,domain},{y,domain}]],
Throw["The map is not operation preserving."]];
map[FindDomain[G1],def]
]
]
MorphismQ[_?AssociationQ]:=True
MorphismQ[___]:=True

KernelMorphism[phi_?MorphismQ,G2_?GroupQ]:=Module[
{idenitity},
identity=FindIdentity[G2];
Return[Select[KeyValueMap[Function[{k,v},{k,v}],phi],#[[2]]==identity&][[All,1]]]
]

Isomorphism[G1_?GroupQ,G2_?GroupQ,def_]:=Module[
{domain},
Catch[
domain=FindDomain[G1];
If[Or@@Flatten[Table[def[G1[x][y]]!=G2[def[x]][def[y]],{x,domain},{y,domain}]],
Throw["The map is not operation preserving."]];
provisionalMap=map[FindDomain[G1],def];
If[Length[domain]!=DeleteDuplicates[Values[provisionalMap]],
Throw["The map is not one-one."]];
Throw[provisionalMap]
]
]

Automorphism[G_?GroupQ,def_]:=Isomorphism[G,G,def]

InnerAutomorphism[G_?GroupQ,x_]:=Module[
{domain},
Catch[
domain=FindDomain[G];
If[!MemberQ[domain,x],Throw["Invalid member."]];
Automorphism[G,G[G[x][#]][ElementInverse[G,x]]&]
]
]

VisualiseMorphism[M_]:=Module[
{x,y,n1,n2,p1,p2},
n1=Length[Keys[M]];
n2=Length[DeleteDuplicates[Values[M]]];
p1=<|Table[x[[i]]->i,{i,1,Length[n1]}]|>;
p2=<|Table[y[[i]]->i,{i,1,Length[n2]}]|>;
Graph[KeyValueMap[Function[{k,v},x[k]->y[v]],M],
VertexCoordinates->Table[x[i]->{p1[i],0},{i,0,n1}]~Join~Table[y[i]->{(n1-n2)/2+p2[i],-3},{i,0,n2}];
VertexLabels->{_[i_]:>i},
VertexStyle->RGBColor["#4A84FF"],
EdgeStyle->RGBColor["#4A84FF"]
]
]

AdditiveGroup[n_Integer]:=FormGroup[Range[0,n-1],Mod[#[[1]]+#[[2]],n]&]

MultiplicativeGroup[n_Integer]:=Module[{coprimes},
coprimes=Select[Range[0,n-1], GCD[#,n]==1&];
FormGroup[coprimes,Mod[#[[1]]#[[2]],n]&]
]

applySymmetry[{s1_, s2_}, n_]:=Module[
{n1,n2},
n1=ToExpression[StringDrop[s1, 1]];
n2=ToExpression[StringDrop[s2, 1]];
If[StringTake[s1,1]=="r",
If[StringTake[s2,1]=="r",
Return["r"<>ToString[Mod[n1+n2,n]]],
Return["s"<>ToString[Mod[n1+n2,n]]]
],If[StringTake[s2,1]=="r",
Return["s"<>ToString[Mod[n1-n2,n]]],
Return["r"<>ToString[Mod[n1-n2,n]]]
]
]          
]
s2n[string_]:=Read[StringToStream[string],Number]
DihedralGroupp[n_]:=Module[
{members},
members=Union[Table["r"<>ToString[i],{i,0,n-1}],Table["s"<>ToString[i],{i,0,n-1}]];
Return[
FormGroup[members,applySymmetry[{#[[1]],#[[2]]},n]&]
]
]

Klein4Group:=Return[<|
"e" -> <|"e" -> "e", "a" -> "a", "b" -> "b", "c" -> "c"|>,
"a" -> <|"e" -> "a", "a" -> "e", "b" -> "c", "c" -> "b"|>,
"b" -> <|"e" -> "b", "a" -> "c", "b" -> "e", "c" -> "a"|>,
"c" -> <|"e" -> "c", "a" -> "b", "b" -> "a", "c" -> "e"|>
|>]

QuaternionGroup:=Return[<|
"1" -> <|"1" -> "1", "-1" -> "-1", "i" -> "i", "-i" -> "-i", "j" -> "j", "-j" -> "-j", "k" -> "k", "-k" -> "-k"|>,
"-1" -> <|"1" -> "-1", "-1" -> "1", "i" -> "-i", "-i" -> "i", "j" -> "-j", "-j" -> "j", "k" -> "-k", "-k" -> "k"|>,
"i" -> <|"1" -> "i", "-1" -> "-i", "i" -> "-1", "-i" -> "1", "j" -> "k", "-j" -> "-k", "k" -> "-j", "-k" -> "j"|>,
"-i" -> <|"1" -> "-i", "-1" -> "i", "i" -> "1", "-i" -> "-1", "j" -> "-k", "-j" -> "k", "k" -> "j", "-k" -> "-j"|>,
"j" -> <|"1" -> "j", "-1" -> "-j", "i" -> "-k", "-i" -> "k", "j" -> "-1", "-j" -> "1", "k" -> "i", "-k" -> "-i"|>,
"-j" -> <|"1" -> "-j", "-1" -> "j", "i" -> "k", "-i" -> "-k", "j" -> "1", "-j" -> "-1", "k" -> "-i", "-k" -> "i"|>,
"k" -> <|"1" -> "k", "-1" -> "-k", "i" -> "j", "-i" -> "-j", "j" -> "-i", "-j" -> "i", "k" -> "-1", "-k" -> "1"|>,
"-k" -> <|"1" -> "-k", "-1" -> "k", "i" -> "-j", "-i" -> "j", "j" -> "i", "-j" -> "-i", "k" -> "1", "-k" -> "-1"|>
|>]

ExternalDirectProduct[Gs___?GroupQ]:=Module[{domain,n},
domain=Tuples[FindDomain/@{Gs}];
n=Length[{Gs}];
FormGroup[domain,Table[{Gs}[[i]][#[[1]][[i]]][#[[2]][[i]]],{i,n}]&]
]


End[]
EndPackage[]
